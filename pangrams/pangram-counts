#!/usr/bin/python3
# Copyright (C) 2024 Dez Moleski dez@moleski.com
# MIT License: All uses allowed with attribution.
#
from wordgames import Word, WordList, AnagramsDict, LetterSetBitmask, ALPHABET_LIST
import sys
from copy import deepcopy
from glob import glob
from operator import itemgetter
from itertools import islice
import datetime
import json
import os.path
import re

if __name__ == "__main__":
   if len(sys.argv) != 1:
      exit("Usage: pangram-counts")
   
   # Read ALL GUESSES file
   ALL_FILE = "./ALL"
   print("Reading all valid guesses file:", ALL_FILE, file=sys.stderr, flush=True, end=' ')
   valid_guesses = WordList.from_file(ALL_FILE)
   valid_guesses.sort()
   print("N =", len(valid_guesses), file=sys.stderr, flush=True)
   
   # Read ANSWERS
   ANSWERS_FILE = "./ANSWERS"
   print("Reading answers file:", ANSWERS_FILE, file=sys.stderr, flush=True, end=' ')
   answers = WordList.from_file(ANSWERS_FILE)
   answers.sort()
   print("N =", len(answers), file=sys.stderr, flush=True)

   # Read WORD-PERCENT list and build up the word_percent dict.
   # We only need to keep individual items for words starting
   # with letters less than our "done from here on..." letter.
   DONE_FROM_LETTER = 'D'
   word_percent = dict()
   WORD_PERCENT_FILE = "./WORD-PERCENT"
   done_percent = 0.0
   print("Done from", DONE_FROM_LETTER, "to Z, percent = ", file=sys.stderr, flush=True, end='')
   if os.path.isfile(WORD_PERCENT_FILE):
      with open(WORD_PERCENT_FILE) as f:
         for word_percent_line in f:
            wp = word_percent_line.split()
            word = wp[0]
            percent = float(wp[1])
            if word[0] < DONE_FROM_LETTER:
               word_percent[word] = percent
            else:
               done_percent += percent
   print(f'{done_percent:.2f}%', file=sys.stderr, flush=True)
   
   # Visit each pangram data file
   print("Scanning data files: ", file=sys.stderr, flush=True, end='')
   all_pgrams = list()
   all_words = WordList()
   answers_used = WordList()
   total_pangrams = 0
   total_pangrams_containing_answers = 0
   n_word_percents_counted = 0
   current_head_word = None
   count_this_head_word = 0
   max_head_word = None
   max_head_word_count = 0
   word_count = dict()
   anagrams = set()
   pangram_counts_by_n_anagrams = [0,0,0,0,0,0,0]
   zero_pangram_words = WordList()
   for letter in ALPHABET_LIST:
      print(letter, file=sys.stderr, flush=True, end=' ')
      datadir = f"./data/{letter}/"
      if os.path.isdir(datadir):
         # Visit each file in the data dir
         paths = sorted(glob(datadir+'*'))
         for filepath in paths:
            with open(filepath, 'r') as f:
               # Read each line and split first into line_list array.
               # Anagrams within the line are like: '[VIGOR|VIRGO]'
               for line in f:
                  line_list = line.split()
                  if line_list[0] == '#':
                     # For lines that start with '#', get the key word
                     # which is either by itself, or the first word of
                     # an anagram set like '[VIRGO|VIGOR]'
                     word_or_anagram = line_list[1]
                     if word_or_anagram[0] == '[':
                        word = word_or_anagram[1:6]
                     else:
                        word = word_or_anagram
                     if word[0] < DONE_FROM_LETTER:
                        done_percent += word_percent[word]
                        n_word_percents_counted += 1
                     # Look for zero pangram count words (and all anagrams)
                     n_pangrams = int(line_list[-1])
                     if n_pangrams == 0:
                        anas_list = re.split(r'\[|\||\]',word_or_anagram)
                        for w in anas_list:
                           if len(w) > 0:
                              zero_pangram_words.add_str(w)
                  else:
                     all_pgrams.append(line_list) # unexpanded anagrams here
                     
                     # Check if this is a new head word. If it is, note it,
                     # check for a new max, and reset our counter for this head word.
                     if line_list[0] != current_head_word:
                        if count_this_head_word > max_head_word_count:
                           max_head_word_count = count_this_head_word
                           max_head_word = current_head_word
                        current_head_word = line_list[0]
                        count_this_head_word = 0
                     
                     # Visit each word or anagram set in the line, and
                     # accumulate the words into our all_words WordList.
                     # Also count how many pangrams are generated by expanding any anagrams.
                     # The trickiest part is counting for each word how many pangrams that
                     # word appears in. This is easy for the single word items, but for
                     # words that are part of an anagram set it's not as straightforward
                     # unless there's only one anagram set in the pangram.
                     count_this_pangram = 1
                     single_words_in_this_pangram = list()
                     anagram_sets_in_this_pangram = list()
                     for item in line_list:
                        # If it's five letters, this item is a single word
                        if len(item) == 5:
                           single_words_in_this_pangram.append(item)
                           # Note duplicated code below; this should really be a function or otherwise refactored!
                           # We don't need to look at a word again after we've seen it one time.
                           if not all_words.contains(item):
                              all_words.add_str(item)
                              if answers.contains(item):
                                 answers_used.add_str(item)
                        else:
                           # It's anagrams like '[VIGOR|VIRGO]', so trim and split it into words.
                           stripped = item.strip('[]')
                           words = stripped.split('|')
                           anagram_sets_in_this_pangram.append(words)
                           # TODO: BUG? what about incrementing word_count for anagrams other than the first one?
                           # Also, if there are anagram sets other than this one, then this word actually appears
                           # in some number of pangrams more than one. This is tricky to fix...
                           #word_count[words[0]] = word_count.get(words[0], 0) + 1
                           count_this_pangram *= len(words)
                           for w in words:
                              anagrams.add(w)
                              # Note duplicated code above; this should really be a function or otherwise refactored!
                              # We don't need to look at a word again after we've seen it one time.
                              if not all_words.contains(w):
                                 all_words.add_str(w)
                                 if answers.contains(w):
                                    answers_used.add_str(w)
                     count_this_head_word += count_this_pangram
                     total_pangrams += count_this_pangram
                     # Single words in this pangram that are NOT in anagram sets
                     # must have their word_count incremented by count_this_pangram.
                     # Also, here is where we check whether any of the pangrams this
                     # line expands to contain a solution (amounts to whether any of
                     # the words or an anagram of a word are an answer).
                     this_pangram_contains_answers = False
                     for item in single_words_in_this_pangram:
                        if answers.contains(item):
                           this_pangram_contains_answers = True
                           break
                           
                     # While we're here, keep a tally of how many pangrams there are for each possible
                     # number of anagrams sets in the pangram (0 to 6).
                     n_sets = len(anagram_sets_in_this_pangram)
                     pangram_counts_by_n_anagrams[n_sets] += 1
                     if not this_pangram_contains_answers:
                        for s in anagram_sets_in_this_pangram:
                           for w in s:
                              if not this_pangram_contains_answers and answers.contains(w):
                                 this_pangram_contains_answers = True
                     
                     if this_pangram_contains_answers:
                        total_pangrams_containing_answers += count_this_pangram
                        for item in single_words_in_this_pangram:
                           word_count[item] = word_count.get(item, 0) + count_this_pangram
                        # If there's exactly one anagram set in this pangram, then each word
                        # in that set gets its count incremented by one.
                        if n_sets == 1:
                           for w in anagram_sets_in_this_pangram[0]:
                              word_count[w] = word_count.get(w, 0) + 1
                        elif n_sets > 1:
                           # This is the tricky case...
                           # First: count_this_pangram is the product of the lengths of all the anagram sets.
                           #
                           # Then for example, consider this base (unexpanded) pangram:
                           #   ABACK FJORD GLITZ [MAQUI|UMIAQ] PHYNX [SWIVE|VIEWS|WIVES]
                           #
                           # So count_this_pangram = 2 * 3 == 6
                           #
                           # To count how many times each word in the anagram sets appears in the expanced pangrams,
                           # we add to each word's count, in each set, count_this_pangram / len(its set).
                           #
                           # For our example,
                           #   MAQUI and UMIAQ get 6 / 2 = 3 added to their counts, and
                           #   SWIVE, VIEWS, and WIVES get 6 / 3 = 2 added to theirs.
                           #
                           # This generalizes to any number of anagram sets in the base pangram.
                           for s in anagram_sets_in_this_pangram:
                              n_this_set = int(count_this_pangram / len(s))
                              for w in s:
                                 word_count[w] = word_count.get(w, 0) + n_this_set
                        
   print('', file=sys.stderr, flush=True)
   
   print("N base pangrams:", len(all_pgrams), file=sys.stderr, flush=True)

   print("N base pangrams by anagram set count:", pangram_counts_by_n_anagrams, file=sys.stderr, flush=True)
   
   print("N expanded pangrams:", total_pangrams, file=sys.stderr, flush=True)
   
   percent = total_pangrams_containing_answers / total_pangrams
   print(f"N pangrams containing solutions: {total_pangrams_containing_answers} / {total_pangrams} = {percent:.0%}", file=sys.stderr, flush=True)
   
   percent = len(all_words) / len(valid_guesses)
   print(f"N words used: {len(all_words)} / {len(valid_guesses)} = {percent:.0%}", file=sys.stderr, flush=True)
   
   percent = len(answers_used) / len(answers)
   print(f"N answers used: {len(answers_used)} / {len(answers)} = {percent:.0%}", file=sys.stderr, flush=True)
   
   print(f'Overall done = {done_percent:.2f}% ({n_word_percents_counted} words before letter {DONE_FROM_LETTER})',
         file=sys.stderr, flush=True)
   print(f'Max head word = {max_head_word}, with {max_head_word_count} pangrams.', file=sys.stderr, flush=True)
   
   print("Top words found in pangrams containing solutions:", file=sys.stderr, flush=True)
   # Sort the (word,count) tuples in the word_count dict by count, highest to lowest, and slice off the top N
   l = sorted(word_count.items(), key=itemgetter(1), reverse=True)
   top100 = l[0:100]
   for t in top100:
      percent = t[1] / total_pangrams_containing_answers
      print(f'1. `{t[0]}` : {percent:.0%} ({t[1]}) ', file=sys.stderr, flush=True, end='')
      if t[0] in anagrams:
         print('*', file=sys.stderr, flush=True)
      else:
         print('', file=sys.stderr, flush=True)
         
   print("\nTop solutions found in pangrams:", file=sys.stderr, flush=True)
   # Filter for top100 solutions
   a = filter(lambda t: answers.contains(t[0]), l)
   top100 = islice(a, 0, 100)
   for t in top100:
      percent = t[1] / total_pangrams
      print(f'1. `{t[0]}` : {percent:.0%} ({t[1]}) ', file=sys.stderr, flush=True, end='')
      if t[0] in anagrams:
         print('*', file=sys.stderr, flush=True)
      else:
         print('', file=sys.stderr, flush=True)
   
   print("\nN head words yielding zero pangrams:", len(zero_pangram_words), file=sys.stderr, flush=True)
   
   print('Solutions NOT in ANY pangram found so far:', file=sys.stderr, flush=True)
   zero_pangram_words.sort()
   n_solutions_in_zero_pangrams = 0
   for w in zero_pangram_words.word_list:
      if answers.contains_word(w) and not answers_used.contains_word(w):
         print(w, file=sys.stderr, flush=True, end=' ')
         n_solutions_in_zero_pangrams += 1
   print('', file=sys.stderr, flush=True)
   print('N solutions in zero pangrams:', n_solutions_in_zero_pangrams, file=sys.stderr, flush=True)
